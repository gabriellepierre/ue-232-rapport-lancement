I) Planning du travail réalisé
Semaine 1 :
2 premiers jours : veille technologique et étude des technologies utilisées par l'entreprise
30 mars : faire liste des choses à changer / améliorer sur Geneste
31 mars : reglement de tous les problemes sauf menu + dates + timesheet ; maquettes pour timesheet (sur téléphone)
01 avril : menu (problème url) + réunion (fruits et legs)
Semaine 2 :
Comptoir sports : référencement (regarder tout)
geneste : rendre code générique (pour timesheet cré + update) ; communication avec BDD pour le formulaire ; commencement de l'edition du formulaire
OMS formation : aide
Yoga : réunion 
semaine 3 : 
Geneste : terminer formulaire, mise en page, et gestion des dates et de l'export CSV des données par semaine des chantiers
Semaine 4 : 
Gaia tree yoga : mise en page, installation et paramétrage de plug-ins, problème avec wordpress donc essayer de déterminer d'où il vient (c'était le theme) et revenir en arrière dans les sauvegarde pour régler le pb (grâce à ovh)
Semaine 5 : Descendre le theme en local pour tester d'où vient le problème, c'était la version de PHP qui n'était pas à jour ; mise en page n° 2 (car on était revenu en arrière), initialisation des cookies / mentions légales / CGU ; création compte stripe du client, recherche de plug in de reservation plus adéquat (tous payants)
Semaine 6 : 
acoudesign : i18 Next (traduction) ; inputs de titres et commentaire, css, fusion de deux zones qui utilisent le même document, mise en page, export HTML (réussi à exporter un fichier, mise dans un contexte (hook) les données nécessaires au document HTML à exporter) commencement CSS du fichier d'export
Gaia tree yoga : barre de cookies; mises à jour de plug-in + thème
Valvert : Projet auquel je n'ai pas participé mais on a regarder tous ensemble les designs, on a chacun donné nos avis sur les choses à améliorer ou non (car rdv avec le client le mardi d'après)
Semaine 7 :
acoudesign : html2canvas, transformer les screens en base64 pour les mettre dans le fichier HTML sans avoir à créer de fichier ZIP (erreur d'ailleurs j'en avais créé un alors qu'il fallait pas) ; mise en page CSS de l'export ; ajout d'un loader ; {FIN du projet}
Semaine 8 : 
Tests acoudesign, gaia tree yoga
Semaine 9 : 
Fin de gaia tree yoga






II) Description du projet et des missions rélisées
a) Geneste
Après avoir étudié les technologies de l'entreprise, le premier projet qu'on m'a confié est l'application métier Geneste.
Pour commencer, on m'a présenté l'application déjà réalisée par mon collègue Roméo. Elle n'était pas tout à fait finalisée, et le client avaient des recommandations. Nous avons donc commencé par éplucher l'application pour faire la liste des choses à changer. Il y avait quelques éléments de mise en page à modifier, mais le changement plus important était le formulaire de présence à remplir par les employés, le coeur de l'application.
Tout d'abord, j'ai étudié le code existant. Découvrant React, j'ai mis quelques temps à bien comprendre l'arborescence de l'application et les composants et fonctions qui la constituent. J'ai choisi de commencer par le plus simple pour m'habituer plus facilement au framework. J'ai modifié des tailles de boutons, ajusté les dimensions de la page pour l'aspect responsive, corrigé quelques fautes d'orthographe, harmonisé la mise en page de formulaires...
Une fois tous ces petits éléments corrigés, j'étais plus à l'aise avec les fichiers et la structure de l'application et de React. 
Avant d'attaquer la feuille de présence, j'ai construit les squelettes de certaines pages pour le chargement au cas où l'utilisateur n'aurait pas une bonne connexion. Le code se présente ainsi :
[Insérer screen adéquat]
Dans React, on peut stocker l'état d'une variable grâce au Hook useState. Celui-ci permet notamment de définir l'état de chargement, et ainsi faire afficher les fonctions de chargement lorsque la page n'est pas tout à fait chargée. Il suffit de mettre une condition qui indique le contenu à afficher si le chargement de la page est en "isLoading", et afficher le résultat final si le chargement de la page est en "success".
Concernant la feuille de présence, j'ai d'abord fais une maquette pour téléphone de la page de présence comme je l'avais envisagée. 
[INSERER SCREEN DES MAQUETTES]
J'ai voulu garder un design proche de celui déjà fait puisqu'il me semblait sobre et moderne. C'est la [num] qui a été retenue.

Nous devions faire en sorte que l'utilisateur puisse marquer le nombre d'heures effectuées pour chaque journée de la semaine, indiquer s'il avait pris son véhicule personnel ou non, et renseigner le motif de son absence. Au départ, la feuille était constitué du nombre d'heures par jour de la semaine, avec deux boutons à cocher (un pour le véhicule personnel sous forme de logo de voiture, et un pour l'absence sous forme de logo d'oeil barré). Nous avons pensé qu'il était plus judicieux d'enlever le bouton pour l'absence, et ajouter "0" au nombre d'heures. Je devais donc insérer une condition qui afficherait une liste déroulante de motifs d'absence si le nombre d'heures était égal à zéro, et afficher une checkbox pour la voiture si le nombre d'heures était supérieur à zéro. C'est lors de cette tâche que j'ai commencé à manipuler des éléments de la base de données.
Je me suis vite rendue compte que le code pouvait être refactorisé et être plus générique. J'ai alors décidé de reprendre le formulaire de timesheet du début, pour ainsi faire fusionner les composants de création et d'édition (au départ très similaire mais dans deux composants différents). En recommençant du début, j'ai remarqué que les éléments de la BDD comme les heures effectuées dans la journée étaient séparées pour chaque jour de la semaine: je ne pouvais donc pas faire une partie de code réutilisable par chaque jour, mais je devais réécrire chaque partie pour chaque jour de la semaine.
J'ai ainsi dû garder un structure similaire à celle d'avant. Cependant, j'ai créé un composant contenant le formulaire (TimesheetForm) partagé par la création et l'édition, ce qui allègera ces deux composants. Même si je n'ai pas pu rendre le code aussi générique que je le souhaitais, j'ai quand même pu refactoriser une partie du code.
Pour ce faire, j'ai inséré des conditions notamment pour changer le titre si des données sont déjà existantes ou non :
[insérer screen]
Le composant de création n'aura plus que la déclaration du formulaire sous cette forme :
<TimesheetForm></TimesheetForm>
Et le composant d'édition aura sensiblement la même chose, mais avec l'insertion de données déjà existantes :
<TimesheetForm timesheet={dataTimesheetById}></TimesheetForm>
Dans le composant de formulaire, j'ai rentré en proprité "timesheet", qui représente les données de la feuille de présence. Toutes mes conditions concernant la création ou l'édition sont faites en fonction de "timesheet" au sein du formulaire. Cette variable est affiliée à "dataTimesheetById" dans le composant d'édition. Ce "dataTimesheetById" est déclaré ainsi :
const { status, data: dataTimesheetById } = useTimesheetByIdQuery(timesheetId);
On comprend ici que pour déterminer la valeur de la donnée, on utilise le hook "useTimesheetByIdQuery". Il est créé au sein de l'application, et il s'agit d'un useQuery du paquet React Query. Son utilité est de faire des requêtes concernnt des données asynchrones via une API. J'ai d'ailleurs pu manipuler ce type de requête.
Au départ, il y avait deux requetes définies dans l'API : une qui permettait d'entrer des données (POST) et une autre qui permettait de les modifier (FETCH). Cependant, en ayant plus qu'un formulaire utilisé pour la création et l'édition et non plus deux formulaires distincts, je devais utiliser une seule requête qui permettait à la fois le POST et le FETCH.

Par ailleurs, chaque variable était stockée dans un useState, ce qui signifie que son état était stocké et mis à jour régulièrement même lorsque la donnée ne changeait pas. J'ai changé cette partie en stockant les variables dans des useWatch, ce qui correpond à stocker l'état de la variable uniquement lorsque celle-ci change. Cela permet d'améliorer les performances de l'application. useWatch fait partie du paquet React Hook Form.
React Hook Form est une librairie de React qui accorde l'utilisation du hook useForm. Comme son nom l'indique, ce hook permet la création de formulaires, mais en simplifiant le code et en améliorant la performance. Pour la feuille de présence, nous avons donc utilisé cette librairie, en l'installant avec npm. 

(parler de la timesheet)
(parler des dates)
(parler de mongodb, mongocompass et traitement des données en nosql)

Les défis de ce projet étaient de manipuler les technologies tout juste découvertes et d'imaginer quelque chose qui plairait au client alors que sa demande était floue. En effet, nous n'avions pas beaucoup de directives du client : nous avions seulement le format papier des feuilles de présence qu'il utilisait jusqu'ici et quelques recommandations sur l'application et son design. Il était donc compliqué de développer une application qui correspondrait à ses attentes. 

b) Gaia tree yoga
Gaia Tree Yoga est un site e-commerce réalisé avec WordPress. Il s'agit d'une entrepreneuse qui donne des cours yoga et souhaitait avoir un site pour présenter sa micro-entreprise et permettre aux clients de réserver leurs cours par ce biais.
Pour ce projet, mes missions étaient de mettre en place un système de réservation, améliorer la mise en page et l'ergonomie du site et installer différents plug-ins. 
J'ai fais un réunion avec la cliente le 8 avril, ce qu nous a permis de faire le point sur tout ce qu'il y avait à amélirer. En terme de mise en page, j'ai harmonisé tout le site en grande partie avec l'outil WPBakery Page Builder.
Concernant les extensions, j'ai installé une extension qui gère les cookies : GRDP cookies ; une extension de sécurité : Wordfence ; une extension pour gérer l'envoi de mail : Easy WP SMTP. J'ai également configuré ces extensions ainsi que WP Fastest Cache, EWWWW Optimiser, et surtout Woocommerce et le module de réservation.
Concernant les packs de cours à acheter, nous avons mis en place un système de code promo transmis lors de l'achat d'un pack et utilisable lors de la réservation d'un cours.
Pour ce faire, j'ai dû modifier le fichier "function.php". J'ai créé une fonction ("generate_coupon") qui permettait la création d'un code aléatoire :
(insérer capture)
Ensuite, j'ai ajouté une condition qui ajustait les paramètres du coupon en fonction du pack acheté (par exemple : utilisable 10 fois pour le pack de 10 séances) : 
(insérer capture)
Il fallait alors générer un mail au client lors du paiement pour lui transmettre le code promo en question :
(insérer capture)
Cette fonction est réalisée lors du paiement grâce au hook woocommerce "woocommerce_order_status_completed" renseigné de cette manière :
add_action (woocommerce_order_status_completed, generate_coupon);
Cette ligne signifie qu'une action est ajouté : lors du changeent du statut de la commande en "Terminée", la fonction "generate_coupon" est lancée.
Pour en arriver au bon résultat, j'ai tout testé en local : j'ai descendu le thème du site et j'ai recréé les pages et produits, et j'ai rajouté tous les plug-ins utilisés. Pour tester les mails, j'ai également utilisé smtp4dev, un serveur d'email permettant de tester les mails en local. 
Ma reproduction en locale m'a également servie à tester d'autres aspects, et notamment à réparer une erreur que j'avais eu à cause du thème (qui s'est avéré venir de la version de php, non compatible avec le thème).
Pour en revenir au système de réservation, je devais tout d'abord chercher des extensions de reservation qui permettraient à l'utilisateur de réserver une ou plusieurs scéances en payant en ligne (avec Paypal et Stripe dans l'idéal) et de permettre la réservation par plusieurs personnes du même créneau horaire. Nous avons donc installé le plug-in Woocommerce Appointments, une extension qui permet la réservation de créneaux horaires, directement liée avec Woocommerce. J'ai créé grâce à ce plug-in des produits planifiables (un pour chaque cours différent).
Pour finir, j'ai amélioré les performances grâce au DevTool Lighthouse qui génère des rapports de performance et indique la marche à suivre pour l'améliorer.

c) Acoudesign
Acoudesign est une entreprise de "solutions d’insonorisation et de sonorisation pour le confort acoustique des interieurs dans le domaine du bâtiment et des transport". Ils réalisent ainsi des tests sur des enceintes, et fournissent un rapport pour chaque test avec :
- le diagramme du transducteur,
- les paramètres, 
- un graphique d’impédance et un graphique d’impédance inversée,
- un graphique sur l’évolution de la température,
- et (insérer dernier graphique)
L’application à réaliser consiste en la production du rapport en lui même. Il doit ainsi contenir des champs qui vont calculer les graphiques selon les données d’un fichier, un champs pour insérer l’image du diagramme du transducteur, et des inputs pour le titre, sous-titre et commentaire. Je me suis occupée principalement de l’export de ces données en html.
Pour ce faire, j’ai d’abord créé une fonction d’export qui exportait un fichier HTML vide pour tester.
(inserer screen)
J’ai utilisé le hook useContext pour stocker les données remplies et les faire passer d’un composant à un autre pour tout déplacer vers la fonction d’export et ainsi construire la page HTML à rendre. 
Après avoir réussi à exporter les données des inputs, j’ai réalisé qu’il serait trop compliqué et trop long de faire passer les graphiques en passant par le contexte. J'ai alors utilisé une autre méthode que celle que j’avais envisagée : mettre dans le contexte des captures d’écrans des graphiques grâce à html2canvas.
« html2canvas » permet de transformer tout ou une partie d’une page en canvas, et donc en image. Pour l’utiliser, il faut faire ainsi :

html2canvas(document.body).then(function(canvas) {
    document.body.appendChild(canvas);
});

Comme on peut le voir, il s’agit d’une promesse. Il faudra la réaliser en asynchrone, de cette manière :
(inserer screen)
Si la promesse n’est pas faite en asynchrone avec un « await », alors l’export ne fonctionnera pas parce que la promesse essayera de fonctionner indéfiniment et rendra (…) REDEMANDER POUR CA
L’écran est donc capturé. Mais dans un fichier HTML seul, les images ne s’affichent pas. Il faut alors les traduire en format base64 pour que le HTML puisse les lire et les afficher sans avoir à joindre de fichier.
(inserer code)
On stocke le résultat dans le contexte pour les afficher dans le fichier HTML exporté.
Ensuite, j'ai rajouté des "loaders" (trouvés sur TailwindUI) pour montrer à l'utilisateur que le fichier ou l'export est en train de charger.
Pour finir, j'ai testé l'application pour trouver toutes les failles et bugs, les régler et mettre le projet en production. Le client a vite donné un retour, qui fût par ailleurs très positif. 

III) Analyse du travail réalisé (points forts, points d'amélioration et actions correctives)





IV) Bilan personnel 

Globalement, mon stage s'est très bien passé. Il correspond à mes attentes sur tous les points. En termes techniques, j'ai pu apprendre de nouvelles technologies, j'ai développé celles que j'avais déjà étudié, j'ai observé au plus près le quotidien d'un développeur, j'ai appris à adopter une approche du travail différente que celle que j'avais en cours pour m'adapter au mieux. En termes humains, le travail au sein d'une équipe est très stimulant, je me suis facilement sentie à l'aise avec mes collègues et mes compétences en babyfoot se sont décuplées. Cependant, je dirais que je n'ai pas eu assez de retour sur le travail que je fournissais. Avant la dernière semaine, je n'ai pas vraiment eu d'avis sur ce que je faisais, et il m'était donc impossible de savoir quoi améliorer, quoi changer ou non.
Pour en revenir aux technologies, j'ai apprécié toutes celles que j'ai apprises. 

