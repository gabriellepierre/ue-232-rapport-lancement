I) Planning du travail réalisé
Semaine 1 :
2 premiers jours : veille technologique et étude des technologies utilisées par l'entreprise
30 mars : faire liste des choses à changer / améliorer sur Geneste
31 mars : reglement de tous les problemes sauf menu + dates + timesheet ; maquettes pour timesheet (sur téléphone)
01 avril : menu (problème url) + réunion (fruits et legs)
Semaine 2 :
Comptoir sports : référencement (regarder tout)
geneste : rendre code générique (pour timesheet cré + update) ; communication avec BDD pour le formulaire ; commencement de l'edition du formulaire
OMS formation : aide
Yoga : réunion 
semaine 3 : 
Geneste : terminer formulaire, mise en page, et gestion des dates et de l'export CSV des données par semaine des chantiers
Semaine 4 : 
Gaia tree yoga : mise en page, installation et paramétrage de plug-ins, problème avec wordpress donc essayer de déterminer d'où il vient (c'était le theme) et revenir en arrière dans les sauvegarde pour régler le pb (grâce à ovh)
Semaine 5 : Descendre le theme en local pour tester d'où vient le problème, c'était la version de PHP qui n'était pas à jour ; mise en page n° 2 (car on était revenu en arrière), initialisation des cookies / mentions légales / CGU ; création compte stripe du client, recherche de plug in de reservation plus adéquat (tous payants)
Semaine 6 : 
acoudesign : i18 Next (traduction) ; inputs de titres et commentaire, css, fusion de deux zones qui utilisent le même document, mise en page, export HTML (réussi à exporter un fichier, mise dans un contexte (hook) les données nécessaires au document HTML à exporter) commencement CSS du fichier d'export
Gaia tree yoga : barre de cookies; mises à jour de plug-in + thème
Valvert : Projet auquel je n'ai pas participé mais on a regarder tous ensemble les designs, on a chacun donné nos avis sur les choses à améliorer ou non (car rdv avec le client le mardi d'après)
Semaine 7 :
acoudesign : html2canvas, transformer les screens en base64 pour les mettre dans le fichier HTML sans avoir à créer de fichier ZIP (erreur d'ailleurs j'en avais créé un alors qu'il fallait pas) ; mise en page CSS de l'export ; ajout d'un loader ; {FIN du projet ?? }
Semaine 8 :






II) Description du projet et des missions rélisées
a) Geneste
Après avoir étudié les technologies de l'entreprise, le premier projet qu'on m'a confié est l'application métier Geneste.
Pour commencer, on m'a présenté l'application déjà réalisée par mon collègue Roméo. Elle n'était pas tout à fait finalisée, et le client avaient des recommandations. Nous avons donc commencé par éplucher l'application pour faire le liste des choses à changer. Il y avait quelques éléments de mise en page à modifier, mais le changement plus important était le formulaire de présence à remplir par les employés, le coeur de l'application.
Tout d'abord, j'ai étudié le code existant. Découvrant React, j'ai mis quelques temps à bien comprendre l'arborescence de l'application et les composants et fonctions qui la constituent. J'ai choisi de commencer par le plus simple pour m'habituer plus facilement au framework. J'ai modifié des tailles de boutons, ajusté les dimensions de la page pour l'aspect responsive, corrigé quelques fautes d'orthographe, harmonisé la mise en page de formulaires...
Une fois tous ces petits éléments corrigés, j'étais plus à l'aise avec les fichiers et la structure de l'application et de React. 
Avant d'attaquer la feuille de présence, j'ai construit les squelettes de certaines pages pour le chargement au cas où l'utilisateur n'aurait pas une bonne connexion.  Le code se présente ainsi :
[Insérer screen adéquat]
Dans React, on peut stocker l'état d'une variable grâce au Hook useState. Celui-ci permet notamment de définir l'état de chargement, et ainsi faire afficher les fonctions de chargement lorsque la page n'est pas tout à fait chargée. Il suffit de mettre une condition qui indique le contenu à afficher si le chargement de la page est en "isLoading", et afficher le résultat final si le chargement de la page est en "success".
Concernant la feuille de présence, j'ai d'abord fais une maquette pour téléphone de la page de présence comme je l'avais envisagée. 
[INSERER SCREEN DES MAQUETTES]
J'ai voulu garder un design proche de celui déjà fait puisqu'il me semblait sobre et moderne. C'est la [num] qui a été retenue.

Nous devions faire en sorte que l'utilisateur puisse marquer le nombre d'heures effectuées pour chaque journée de la semaine, indiquer s'il avait pris son véhicule personnel ou non, et renseigner le motif de son absence. Au départ, la feuille était constitué du nombre d'heures par jour de la semaine, avec deux boutons à cocher (un pour le véhicule personnel sous forme de logo de voiture, et un pour l'absence sous forme de logo d'oeil barré). Nous avons pensé qu'il était plus judicieux d'enlever le bouton pour l'absence, et ajouter "0" au nombre d'heures. Je devais donc insérer une condition qui afficherait une liste déroulante de motifs d'absence si le nombre d'heures était égal à zéro, et afficher une checkbox pour la voiture si le nombre d'heures était supérieur à zéro. C'est lors de cette tâche que j'ai commencé à manipuler des éléments de la base de données.
Je me suis vite rendue compte que le code pouvait être refactorisé et être plus générique. J'ai alors décidé de reprendre le formulaire de timesheet du début, pour ainsi faire fusionner les composants de création et d'édition (au départ très similaire mais dans deux composants différents). En recommençant du début, je me suis rendue compte que les éléments de la BDD comme les heures effectuées dans la journée étaient séparées pour chaque jour de la semaine: je ne pouvais odnc pas faire une partie de code réutilisable pour chaque journée, mais je devais réécrire chaque partie pour chaque jour de la semaine.
J'ai ainsi dû garder un structure similaire à celle d'avant. Cependant, j'ai quand même pu fusionner les deux composants (création et édition). Pour ce faire, j'ai inséré des conditions notamment pour changer le titre si des données sont déjà existantes ou non :
[insérer screen]
Finalement, l'application sera composée des composants Création et Edition comme avant, mais j'ai créé un troisième composant de formulaire (TimesheetForm) qui reprendra le code partagé et rendra ces deux composants plus légers pour qu'un seul soit chargé. Ainsi, le composant de création n'aura plus que la déclaration du formulaire sous cette forme :
<TimesheetForm></TimesheetForm>
Et le composant d'édition aura pareil mais avec l'insertion de données déjà existantes ; de cette manière :
<TimesheetForm timesheet={dataTimesheetById}>></TimesheetForm>
Dans le composant de formulaire, j'ai rentré en proprité "timesheet", qui représente les données de la feuille de présence. Toutes mes conditions concernant la création ou l'édition sont faites en fonction de "timesheet" au sein du formulaire. Cette variable est affiliée à "dataTimesheetById" dans le composant d'édition. Ce "dataTimesheetById" est déclaré ainsi :
const { status, data: dataTimesheetById } = useTimesheetByIdQuery(timesheetId);
On comprend ici que pour déterminer la valeur de la donnée, on utilise le hook "useTimesheetByIdQuery". Il est créé au sein de l'application, et il s'agit d'un useQuery (du paquet React Query). Son utilité est de faire des requêtes concernnt des données asynchrones via une API. J'ai d'ailleurs pu manipuler ce type de requête.
Au départ, il y avait deux requetes définies dans l'API : une qui permettait d'entrer des données (POST) et une autre qui permettait de les modifier (FETCH). Cependant, pour rendre le code le plus générique possible, je devais utiliser une seule requête qui permettait à la fois le POST et le FETCH. 

Par ailleurs, chaque variable était stockée dans un useState, ce qui signifie que son état était stocké et mis à jour régulièrement même lorsque la donnée ne changeait pas. J'ai changé cette partie en stockant les variables dans des useWatch, ce qui correpond à stocker l'état de la variable uniquement lorsque celle-ci change. Cela permet d'améliorer les performances de l'application. useWatch fait partie du paquet React Hook Form.
React Hook Form est une librairie de React qui accorde l'utilisation du hook useForm. Comme son nom l'indique, ce hook permet la création de formulaires, mais en simplifiant le code et en améliorant la performance. Pour la feuille de présence, nous avons donc utilisé cette librairie, en l'installant avec npm de NodeJS. 


Les défis de ce projet étaient de manipuler les technologies tout juste découvertes et d'imaginer quelque chose qui plairait au client alors que sa demande était floue. En effet, nous n'avions pas beaucoup de directives du client : nous avions seulement le format papier des feuilles de présence qu'il utilisait jusqu'ici et les recommandations sur l'application citées plus tôt. Il était donc compliqué de développer une application qui correspondrait à ses attentes. 




b) Gaia tree yoga
Gaia Tree Yoga est un site e-commerce réalisé avec WordPress. Il s'agit d'une entrepreneuse qui donne des cours yoga et souhaitait avoir un site pour présenter sa micro-entreprise et permettre aux clients de révserver leurs cours via ce biais.
Lorsque je suis arrivée chez Becoms, le projet était déjà commencé. Je devais tout d'abord chercher des extensions de reservation qui permettraient au client de réserver une ou plusieurs scéances (il est possible d'acheter des packs), qui permettaient le paiement en ligne (avec Paypal et Stripe dans l'idéal). Après quelques recherches, je m'étais dirigée vers le plug-in Booking Calendar, l'extension de reservation gratuite la plus utilisée. La documentation était complète et l'extension me semblait adéquate. Cependant, en la paramétrant, je me suis rendue compte qu'elle ne permettait pas de réserver des créneaux horaires, et qu'elle ne permettait pas non plus de mettre en place des cours à plusieurs. J'ai donc dû recommencer mes recherches mais en sachant cette fois ce quoi chercher : pas seulement une extension de reservation, mais de reservation de classes. Ainsi, j'ai pu trouver des extensions qui permettent de reserver un crénau dans la journée et non plusieurs jours. J'ai donc d'ici trié selon les extensions qui permettaient le paiement avec Paypal et Stripe automatisé et que plusieurs personnes pouvaient resver le même cours. J'ai ainsi pu trouver dexu extensions qui s'accordaient avec les demandes du client : (continuer truc sur extension).
J'ai fais une réunion avec Maryline le vendredi 8 avril. De là, j'ai dû éplucher l'entièreté du site pour savoir quoi changer ormis l'extension de reservation. Je me suis rendue compte que quelques éléments de mise en page n'étaient pas finalisés. J'ai donc modifié le footer, j'ai harmonisé les headers qui n'étaient pas tous mis en page de la même manière, (...)
Pour en revenir aux extensions, j'ai également installé une extension qui gère les cookies : GRDP cookies ; une extension de sécurité : Wordfence ; (...)




c) Acoudesign





III) Analyse du travail réalisé (points forts, points d'amélioration et actions correctives)





IV) Bilan personnel 



